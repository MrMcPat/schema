"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MUX_API_BASE_URL = void 0;
const mux_node_1 = require("@mux/mux-node");
const command_1 = require("@oclif/command");
const chalk = require("chalk");
const fs = require("fs-extra");
const path = require("path");
const config_1 = require("../config");
exports.MUX_API_BASE_URL = "https://api.mux.com";
class CommandBase extends command_1.default {
    constructor() {
        super(...arguments);
        this.configFile = path.join(this.config.configDir, 'config.json');
    }
    async readConfigV1() {
        var _a, _b, _c, _d, _e, _f, _g;
        const configAlreadyExists = await fs.pathExists(this.configFile);
        try {
            const configRaw = configAlreadyExists
                ? await fs.readJSON(this.configFile)
                : {};
            // Mux SDK configuration options
            configRaw.tokenId = (_a = process.env.MUX_TOKEN_ID) !== null && _a !== void 0 ? _a : configRaw.tokenId;
            configRaw.tokenSecret = (_b = process.env.MUX_TOKEN_SECRET) !== null && _b !== void 0 ? _b : configRaw.tokenSecret;
            configRaw.signingKeyId = (_c = process.env.MUX_SIGNING_KEY) !== null && _c !== void 0 ? _c : configRaw.signingKeyId;
            configRaw.signingKeySecret = (_d = process.env.MUX_PRIVATE_KEY) !== null && _d !== void 0 ? _d : configRaw.signingKeySecret;
            // Mux CLI specific configuration options
            configRaw.configVersion = (_e = configRaw.configVersion) !== null && _e !== void 0 ? _e : 1;
            configRaw.baseUrl = (_g = (_f = process.env.MUX_CLI_BASE_URL) !== null && _f !== void 0 ? _f : configRaw.baseUrl) !== null && _g !== void 0 ? _g : exports.MUX_API_BASE_URL;
            return config_1.MuxCliConfigV1.check(configRaw);
        }
        catch (err) {
            if (configAlreadyExists) {
                // we have a bad config file, and should say so
                this.log(chalk `{bold.underline.red Invalid Mux configuration file found at {bold.underline.cyan ${this.configFile}}:}\n\n` +
                    Object.entries(err.details).map(tup => " - " + chalk `{cyan ${tup[0]}}` + `: ${tup[1]}`) +
                    chalk `\n\nPlease fix the file or run {bold.magenta mux init --force} to create a new one.`);
            }
            else {
                this.log(chalk `{bold.underline.red No Mux configuration file found!} If you'd like to create ` +
                    chalk `one, run the {bold.magenta init} command. Otherwise, make sure to have the ` +
                    chalk `{bold.yellow MUX_TOKEN_ID} and {bold.yellow MUX_TOKEN_SECRET} environment variables set. ðŸ‘‹`);
            }
            process.exit(1);
        }
    }
    async init() {
        if (this.id === 'init')
            return; // If we're initing we don't want any of this!
        const config = await this.readConfigV1();
        const mux = new mux_node_1.default(config === null || config === void 0 ? void 0 : config.tokenId, config === null || config === void 0 ? void 0 : config.tokenSecret, {
            baseUrl: config === null || config === void 0 ? void 0 : config.baseUrl,
        });
        this.Mux = mux;
        this.Video = this.Mux.Video;
        this.Data = this.Mux.Data;
        this.JWT = mux_node_1.default.JWT;
    }
}
exports.default = CommandBase;
