"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const chalk = require("chalk");
const clipboard = require("clipboardy");
const fs = require("fs-extra");
const inquirer = require("inquirer");
const Listr = require("listr");
const path = require("path");
const request = require("request");
const asset_base_1 = require("../../command-bases/asset-base");
class AssetsCreate extends asset_base_1.default {
    getFilePaths(filePath, filter = '') {
        if (fs.lstatSync(filePath).isDirectory()) {
            return fs.readdirSync(filePath).filter(file => file.match(filter));
        }
        return [filePath];
    }
    uploadFile(filePath, url) {
        return new Promise((resolve, reject) => {
            fs.createReadStream(path.resolve(process.cwd(), filePath)).pipe(request
                .put(url)
                .on('response', resolve)
                .on('error', reject));
        });
    }
    pollUpload(uploadId) {
        return new Promise((resolve, reject) => {
            const poll = () => setTimeout(async () => {
                try {
                    const upload = await this.Video.Uploads.get(uploadId);
                    if (upload.status === 'asset_created') {
                        return resolve(upload);
                    }
                    else if (upload.status === 'errored') {
                        return reject(upload);
                    }
                    poll();
                }
                catch (err) {
                    reject(err);
                }
            }, 500);
            poll();
        });
    }
    async run() {
        const { args, flags } = this.parse(AssetsCreate);
        let assetBodyParams = {
            new_asset_settings: {
                playback_policy: flags.private ? ['signed'] : ['public'],
            },
        };
        const regex = new RegExp(flags.filter || '', 'ig');
        const files = this.getFilePaths(path.resolve(process.cwd(), args.path)).filter(file => file.match(regex));
        let prompt = { files };
        if (files.length === 0) {
            return this.log(`We were unable to find any files. You might want to double check your path or make sure your filter isn't too strict`);
        }
        else if (files.length > 1) {
            prompt = await inquirer.prompt([
                {
                    type: 'checkbox',
                    name: 'files',
                    message: 'We found a few files! Do all of these look good?',
                    choices: files,
                    default: files,
                },
            ]);
        }
        const tasks = prompt.files.map((file) => ({
            title: `${file}: getting direct upload URL`,
            task: async (ctx, task) => {
                const upload = await this.Video.Uploads.create(assetBodyParams);
                task.title = `${file}: uploading`;
                await this.uploadFile(path.resolve(process.cwd(), args.path, file), upload.url);
                task.title = `${file}: waiting for asset to be playable`;
                const { asset_id: assetId } = await this.pollUpload(upload.id);
                if (!assetId) {
                    throw new Error(`Asset for upload '${upload.id}' failed to resolve.`);
                }
                const asset = await this.pollAsset(assetId);
                const playbackUrl = this.playbackUrl(asset);
                task.title = `${file}: ${playbackUrl}`;
                ctx.assets = [
                    ...(ctx.assets || [['Filename', 'Asset ID', 'PlaybackURL']]),
                    [file, asset.id, playbackUrl],
                ];
            },
        }));
        // I hate this `any` here, but I'm running into a weird issue casting
        // the `tasks` above to an array of `ListrTasks[]`.
        try {
            const finalCtx = await new Listr(tasks, {
                concurrent: flags.concurrent,
            }).run();
            const tsv = finalCtx.assets
                .map((row) => row.join('\t'))
                .join('\n');
            if (prompt.files.length > 1 && !process.env.WSL_DISTRO_NAME) {
                await clipboard.write(tsv);
                return this.log(chalk `
  ðŸ“¹ {bold.underline Assets ready for your enjoyment:}
  ${tsv}

  {blue (copied to your clipboard)}`);
            }
            await clipboard.write(finalCtx.assets[1][2]);
            return this.log(chalk `
  ðŸ“¹ {bold.underline Asset ready for your enjoyment:}
  ${tsv}

  {blue (since you only uploaded one asset, we just added the playback URL to your clipboard.)}`);
        }
        catch (err) {
            // TODO: make this clearer / separate it out per video for more obvious debugging.
            console.log(chalk.redBright('Error:') +
                "\n\n" +
                err);
            if (err instanceof Error) {
                this.error(err);
            }
            else {
                throw err;
            }
        }
    }
}
exports.default = AssetsCreate;
AssetsCreate.description = 'Create a new asset in Mux via a local file';
AssetsCreate.args = [
    {
        name: 'path',
        description: "local path for the file (or folder) you'd like to upload",
        required: true,
    },
];
AssetsCreate.flags = Object.assign(Object.assign({}, asset_base_1.default.flags), { filter: command_1.flags.string({
        char: 'f',
        description: 'regex that filters the selected destination if the provided path is a folder',
    }), concurrent: command_1.flags.integer({
        char: 'c',
        description: 'max number of files to upload at once',
        default: 3,
    }), private: command_1.flags.boolean({
        char: 'p',
        default: false,
    }) });
